#include "global.th"
#include "modbus.th"

bool upload_succesful=true;

/* \file xmodem.tc
 * This file contains the X-Modem protocol realisation to upload firmware
 * into the hexagon sensors
 */

#define XMODEM_PACKET_SIZE      128
#define XMODEM_SOH              0x01
#define XMODEM_EOT              0x04
#define XMODEM_ACK              0x06 
#define XMODEM_NACK             0x15
#define XMODEM_ETB              0x17
#define XMODEM_CAN              0x18
#define XMODEM_16BITCRC         'C'
#define XMODEM_EOF              0x1A    // Ctrl+Z
#define MAX_RETRIES             10
#define XMODEM_TIMEOUT			3000	// in ms


bool
do_xmodem_upload(string filename)
{
	kp.enabled=NO;
	string data, pkt;
	word job_size, block_num;

	for(;;) {
		doevents;
		pkt = ser.getdata(255);
		if(pkt[0] == XMODEM_NACK || pkt[0] == 'C'){
			break;
			}
		else{
			delay_ms(1000);
			pkt = ser.getdata(255);
			}
		if(pkt[0] == XMODEM_NACK || pkt[0] == 'C'){
			break;
			}
		else{			
			kp.enabled=YES;
			return false;
			}
			
	}
	romfile.open(filename);
	job_size=romfile.size/128;
	firmware_upload_in_prog_screen();
	for(block_num=1; block_num<=job_size; ++block_num) {
		data=romfile.getdata(128);
		if(!transmit_block(data, block_num, job_size))
			break;
	}
	
	serial_send(chr(XMODEM_EOT));
	serial_send(chr(XMODEM_ETB));
	if (upload_succesful)  
		upload_successful_screen();
		kp.enabled=YES;
	return OK;
}



static bool
transmit_block(byte *data, word blk, word blockcnt)
{
	string pkt, rpl;
	byte retries;
	byte i;
	word cksum;
	
	for(retries=0;;) {
		/* Header */
		pkt = chr(XMODEM_SOH) + chr(blk & 0xFF) + chr(0xFF - (blk & 0xFF));
		cksum = 0;
		
		/* Body */
		for(i=0; i<XMODEM_PACKET_SIZE; ++i) {
			pkt += chr(data[i]);
			cksum += data[i];
		}
		
		/* Checksum */
		pkt += chr(cksum & 0xFF);

		sys.debugprint("Sending packet #" + str(blk) + " of " + str(blockcnt) + "\r\n");
		update_firmware_upload_screen(blk, blockcnt);
#if 0		
		DBG(wdump((byte *)&pkt[3]));
		DBG(wdump((byte *)&pkt[32+3]));
		DBG(wdump((byte *)&pkt[64+3]));
		DBG(wdump((byte *)&pkt[96+3]));
#endif

retransmit:	
		serial_send(pkt);
		sys.timercountms=0;
		/* Check timeout */
		do {
			rpl = ser.getdata(128);
			if(sys.timercountms>3000)
			{
				upload_failed_screen();
				upload_succesful=false;
				return false;
			}
				
		} while(rpl == "");

		/* Parse reply packet
		 */
		switch(rpl[0]) {
			case XMODEM_NACK:
				sys.debugprint("NACK");
				if(MAX_RETRIES == ++retries) {
					sys.debugprint("Max. transmission retries ("+str(retries)+") reached. Giving up\r\n");
					break;
				}
				sys.debugprint("Resending #" + str(blk) + "\r\n");
				goto retransmit;
				
			case XMODEM_ACK:
				sys.debugprint("ACK\r\n");
				return true;
				
			default:
				sys.debugprint("Got unknown reply\r\n");
				break;
		}
	} 
	return false;
}