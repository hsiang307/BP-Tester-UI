#include "global.th"
#include "hal.th"
#include "modbus.th"

bool upload_succesful=true;
ioport *p;
void
on_sys_init()
{
	modbus_init();
	tibbit_install(0, TB_05);
	tibbit_install(1, TB_00_3);
	p = ioport_alloc(0, IO_RS485, -1);
	lcd_init();
}

void
reprogram_address(byte oldaddr, byte newaddr)
{
	string args;
	args = chr(0) +  chr(newaddr);
	modbus_request(p, oldaddr, PRESET_SINGLE_REGISTER, SCAN_SENSORS, 1, args);
}

void
scan_sensors(unsigned char w)
{
	modbus_request(p, w, READ_HOLDING_REGISTERS, SCAN_SENSORS, 4, "");
	get_response();
	if (modbus_finished()){
		set_sensor_id(w);
	}
}

void
get_sensor_type(unsigned char w)
{
	string result;
	modbus_request(p, w, READ_INPUT_REGISTERS, GET_SENSOR_TYPE, 1, "");
	get_response();
	result = modbus_result();
	result=result[4];
	set_sensor_type(result);
}

void
get_sensor_data(unsigned char w,unsigned char x)
{
	string result, hum, rawdata;
	
	switch(x){
	case 1:	//temp&hum
		modbus_request(p, w, READ_INPUT_REGISTERS, READ_TEMP_H_VALUE, 1, "");
		break;
	case 2:	//temp
		modbus_request(p, w, READ_INPUT_REGISTERS, READ_TEMP_VALUE, 1, "");
		break;
	case 3:	//light
		modbus_request(p, w, READ_INPUT_REGISTERS, READ_LIGHT_VALUE, 1, "");
		break;
	default:
	}
	get_response();
	rawdata = modbus_result();
	if(rawdata != "") {
			switch(x) {
				case 1:
					result=get_temp_and_hum(rawdata, w);
					break;
				case 2:
					result=get_temp(rawdata);
					break;
				case 3:
					result=get_light(rawdata);
					break;
				default:
				return;
		}
	}
	set_sensor_data(result);
}

string 
get_temp_and_hum(string rawdata, unsigned char w){
	string temp, hum, result;
	temp=hex_to_dec(hex(rawdata[3]),hex(rawdata[4]));
	temp=left(temp,len(temp)-1)+"."+right(temp,1);
	if (len(temp)<=2){
	temp="0"+temp;
	}
	modbus_request(p, w, READ_INPUT_REGISTERS, READ_HUM_VALUE, 1, "");
	get_response();
	rawdata = modbus_result();
	hum=hex_to_dec(hex(rawdata[3]),hex(rawdata[4]));
	hum=left(hum,len(hum)-1)+"."+right(hum,1);
	if (len(hum)<=2){
	hum="0"+hum;
	};
	result=temp+"x"+hum;
	return result;
} 

string 
get_temp(string rawdata){
	string temp;
	temp=hex_to_dec(hex(rawdata[3]),hex(rawdata[4]));
	temp=left(temp,len(temp)-2)+"."+right(temp,2);
	if (len(temp)<=3){
	temp="0"+temp;
	}
	return temp;
}

string 
get_light(string rawdata){
	string light;
	light=hex_to_dec(hex(rawdata[3]),hex(rawdata[4]));
	light=val(light);
	return light;
}

string
hex_to_dec(string hi,string lo)
{
	string dec_val;
	if (len(lo)==3){
		lo="0"+right(lo,1);
	}else{
		lo=right(lo,2);
	}
	dec_val=hi+lo;
	dec_val=val(dec_val);
	return dec_val;	
}

void get_response(){
	
	sys.timercountms=0;
	while(!modbus_finished()){
		on_modbus_data_arrival(MODBUS_SERIAL);
		if (sys.timercountms>100){
		break;
		}
	}
}

//unsigned long sp;
/* \file xmodem.tc
 * This file contains the X-Modem protocol realisation to upload firmware
 * into the hexagon sensors
 */

#define XMODEM_PACKET_SIZE      128
#define XMODEM_SOH              0x01
#define XMODEM_EOT              0x04
#define XMODEM_ACK              0x06 
#define XMODEM_NACK             0x15
#define XMODEM_ETB              0x17
#define XMODEM_CAN              0x18
#define XMODEM_16BITCRC         'C'
#define XMODEM_EOF              0x1A    // Ctrl+Z
#define MAX_RETRIES             10
#define XMODEM_TIMEOUT			3000	// in ms

static word
swapb(word t)
{
	return ((t >> 8) & 0xFF) | ((t & 0xFF) << 8);
}

static bool
transmit_block(byte *data, word blk, word blockcnt)
{
	string pkt, rpl;
	byte retries;
	byte i;
	word cksum;
	
	for(retries=0;;) {
		/* Header */
		pkt = chr(XMODEM_SOH) + chr(blk & 0xFF) + chr(0xFF - (blk & 0xFF));
		cksum = 0;
		
		/* Body */
		for(i=0; i<XMODEM_PACKET_SIZE; ++i) {
			pkt += chr(data[i]);
			cksum += data[i];
		}
		
		/* Checksum */
		pkt += chr(cksum & 0xFF);

		sys.debugprint("Sending packet #" + str(blk) + " of " + str(blockcnt) + "\r\n");
		update_firmware_upload_screen(blk, blockcnt);
#if 0		
		DBG(wdump((byte *)&pkt[3]));
		DBG(wdump((byte *)&pkt[32+3]));
		DBG(wdump((byte *)&pkt[64+3]));
		DBG(wdump((byte *)&pkt[96+3]));
#endif

retransmit:	
		serial_send(p, pkt);
		sys.timercountms=0;
		/* Check timeout */
		do {
			rpl = serial_recv(p, 1);
			if(sys.timercountms>3000)
			{
				upload_failed_screen();
				upload_succesful=false;
				return false;
			}
				
		} while(rpl == "");

		/* Parse reply packet
		 */
		switch(rpl[0]) {
			case XMODEM_NACK:
				sys.debugprint("NACK");
				if(MAX_RETRIES == ++retries) {
					sys.debugprint("Max. transmission retries ("+str(retries)+") reached. Giving up\r\n");
					break;
				}
				sys.debugprint("Resending #" + str(blk) + "\r\n");
				goto retransmit;
				
			case XMODEM_ACK:
				sys.debugprint("ACK\r\n");
				return true;
				
			default:
				sys.debugprint("Got unknown reply\r\n");
				break;
		}
	} 
	
	return false;
}


bool
do_xmodem_upload(string fwfile)
{
	word blk, blockcnt;
	byte i;
	dword bc;
	firmware fw;
	byte *data;
	string pkt;
	word *temp;
	
/* 0x340 is a starting address of the main firmware file.
 * The addresses 0x0 - 0x330 occupied by the monitor
 */
#define FW_OFFSET (0x0800*sizeof(word))

	romfile.open(fwfile);
    unsigned long ptr = romfile.pointer32;
	unsigned long fwsize = romfile.size;
	/* 0x340 is a start address of the firmware (not monitor!)
	 */
	data = (byte *)ptr + FW_OFFSET;
	bc =   fwsize + FW_OFFSET;
	temp = (word *)data + FW_OFFSET;
	
	blockcnt = bc / XMODEM_PACKET_SIZE;
	if(bc % XMODEM_PACKET_SIZE != 0)
		++blockcnt;
		
 	/*
	 * The receiving side is sending NACK or 'C' to indicate that it ready to 
	 * begin data exchange. NACK means that receiver will use 1-byte CRC and
	 * 'C' indicates that CRC expected to be 16-bits.
	 * After that, we begin to send 132 or 133-byte packets, 
	 * which consists of SOH marker, packet number (and 0xFF-complement byte), 
	 * 128 bytes of data and 1 or 2 bytes of CRC	
	 */
	 
	for(;;) {
		pkt = ser.getdata(255);
		if(pkt[0] == XMODEM_NACK || pkt[0] == 'C')
			break;
		else
			return false;
	}

	sys.debugprint("Got NACK from target\r\n");
	sys.debugprint("Transferring "+str(blockcnt)+" blocks\r\n");
	firmware_upload_in_prog_screen();
	for(blk=1; blk<=blockcnt; ++blk) {
		if(!transmit_block(data, blk, blockcnt))
			break;
		data += XMODEM_PACKET_SIZE;
	}
	
	sys.debugprint("EOT\r\n");
	serial_send(p, chr(XMODEM_EOT));
	
	sys.debugprint("ETB\r\n");
	serial_send(p, chr(XMODEM_ETB));

	sys.debugprint("Success\r\n");
		if (upload_succesful)  
		upload_successful_screen();
	
	return OK;
}

