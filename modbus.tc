#include "global.th"
#include "modbus.th"

#define MB_RQ_SIZE sizeof(modbus_req)
static modbus_state _state;
static dword _timeout;
static string _packet; 	// data accumulation buffer
static byte _pdu_len;	// PDU length byte

void
modbus_init()
{
	_state = MODBUS_IDLE;
}

/* \brief CRC generation function */
word 
crc16(byte *data, byte byte_cnt)
{
    byte crc_hi = 0xFF;  
    byte crc_lo = 0xFF; 
    word idx; 
    
    while(byte_cnt--) { 
        idx = crc_hi ^ *data++; 
        crc_hi = crc_lo ^ _crc_table_hi[idx];
        crc_lo = _crc_table_lo[idx];
    }
	return (crc_hi << 8) | crc_lo;
}


/*! \brief Issue ModBus request */
void
modbus_request(ioport *port, byte devaddr, byte request, word start, word count, string regdata)
{
	string<MB_RQ_SIZE+4> data;
	data = chr(devaddr);
	data += chr(request);
	data += chr(start >> 8);
	data += chr(start & 0xFF);
	if(0 == len(regdata)) {
		data += chr(count >> 8);
		data += chr(count & 0xFF);
	} else {
		data += regdata;
	}
	word crc = crc16((byte *)&data[0], len(data));
	data += chr(crc >> 8);
	data += chr(crc & 0xFF);
	_packet = "";
	_state = MODBUS_IDLE;
	_timeout = sys.timercountms + MODBUS_TIMEOUT;
	serial_send(port, data);
}

/* This routine should be called either from on_sock_data_arrival() or 
 * on_ser_data_arrival() event handlers
 * Routine receives and parses ModBus PDU
 */
void
on_modbus_data_arrival(modbus_source src)
{
	string tmp = "";
	tmp = ser.getdata(255);
	switch(_state) {
		case MODBUS_FINISHED:
			sys.debugprint("Previous ModBus packet was not processed");
		case MODBUS_IDLE:
			_packet = "";
			_state = MODBUS_RECEIVING;
			/* fall through to the next case */
		case MODBUS_RECEIVING:
			_packet += tmp;
			break;
	}
	if(len(_packet) >= 2) {
		_pdu_len = _packet[2] + 5; // Byte count, including slave address, crc, byte length and function code
		if(len(_packet) >= _pdu_len) {
			delay_ms(1);
			//char c = "&hFF" 
			string c1 = _packet[9];
			string c2 = _packet[10];
			if(c1=="-86"  && c2=="85"){	
				_state = MODBUS_FINISHED;			
			}
		}
	}
}

bool
modbus_finished()
{
	return _state == MODBUS_FINISHED;
}

string
modbus_result()
{
	return _packet;
}

static string<16> _hex = "0123456789ABCDEF";


string<2>
tohex(unsigned char c)
{
    char *hx = _hex;
	return chr(hx[(c >> 4) & 0x0F]) + chr(hx[c & 0x0F]);
}

static bool
_is_serial_type(iotype t)
{
	return (IO_RS485 == t);
}


bool
is_serial_port(ioport *p)
{
	return _is_serial_type(ioport_type(p));
}


string
serial_recv(ioport *p, byte maxlen)
{
	ser.num = p->d.ser.spn;
	return ser.getdata(maxlen);
}


void
serial_setup(ioport *p)
{	
	if(!is_serial_port(p))
		return;
		
	ser.num = p->d.ser.spn;
	ser.rxbuffrq(2);
	ser.txbuffrq(2);
	sys.buffalloc();
	ser.rxclear();
	ser.txclear();
	ser.notifysent(1);
	ser.mode = PL_SER_MODE_UART;
	ser.bits = PL_SER_BB_8;
	ser.parity =  PL_SER_PR_NONE;
	ser.flowcontrol = PL_SER_FC_DISABLED;
	ser.interface = PL_SER_SI_HALFDUPLEX;
	ser.enabled = NO;
	ser.baudrate = ser.div9600/4;
	ser.enabled = YES;	
}


void
serial_send(ioport *p, string data)
{
	if(!is_serial_port(p) || 0 == len(data))
		return;
		
	ser.num = p->d.ser.spn;
	ser.notifysent(1);
	ser.setdata(data);
	ser.send();
}

/* Please keep this table in sync with enum!
 * First member (tibbit type id) designated for error checking
 */
static tibbit_info _ti_info[] = 
{
	{ TB_NONE, 	0, 0 },
	{ TB_00_1, 	1, 0 },
	{ TB_00_2, 	1, TBSLOT_PIN_D_UNUSED },
	{ TB_00_3, 	1, TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_01, 	1, 0 },
	{ TB_02, 	2, 0 },
	{ TB_03_1, 	1, TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_03_2, 	1, TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_04_1, 	1, TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_04_2, 	1, TBSLOT_PIN_D_UNUSED },
	{ TB_04_3,	1, TBSLOT_PIN_D_UNUSED },
	{ TB_04_4, 	1, 0 },
	{ TB_04_5, 	1, TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_04_6, 	1, TBSLOT_PIN_D_UNUSED },
	{ TB_04_7,	1, TBSLOT_PIN_D_UNUSED },
	{ TB_04_8, 	1, 0 },
	{ TB_05,	1, TBSLOT_PIN_D_UNUSED },
	{ TB_06,	2, TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_07,	1, TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_08,	1, 0 },
	{ TB_09,	1, TBSLOT_PIN_B_UNUSED | TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_10,	1, TBSLOT_PIN_B_UNUSED | TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_11,	1, 0 },
	{ TB_12,	1, TBSLOT_PIN_B_UNUSED | TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_13,	1, TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_14,	1, TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_15,	1, TBSLOT_PIN_B_UNUSED | TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_16, 	1, 0 },
	{ TB_17,	1, 0 },
/* Tibbits below is just connectors */
	{ TB_18,	1, TBSLOT_C1_OR_C2 },
	{ TB_19,	2, TBSLOT_C1_OR_C2 },
	{ TB_20,	2, TBSLOT_C1_OR_C2 },
	{ TB_21,	1, TBSLOT_C1_OR_C2 },
/* Normal tibbits again */	
	{ TB_22,	2, TBSLOT_PIN_B_UNUSED | TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_23,	2, TBSLOT_PIN_B_UNUSED | TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_24,	1, TBSLOT_PIN_D_UNUSED },
	{ TB_25,	2, TBSLOT_PIN_B_UNUSED | TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_26,	1, TBSLOT_PIN_D_UNUSED },
/* Sensors */	
	{ TB_27,	1, TBSLOT_C1_OR_C2 },
	{ TB_28,	1, TBSLOT_C1_OR_C2 },
	{ TB_29,	1, TBSLOT_C1_OR_C2 },
	{ TB_30,	1, TBSLOT_C1_OR_C2 },
/* PIC coprocessor */	
	{ TB_31,	1, 0 },
/* Reserved/Not exists */	
	{ TB_32,	0, 0 },
	{ TB_33,	0, 0 },
	{ TB_34,	0, 0 },
/* Sensors again */	
	{ TB_35,	1, TBSLOT_C1_OR_C2 },
	{ TB_36,	1, TBSLOT_C1_OR_C2 },
	{ TB_37,	1, TBSLOT_C1_OR_C2 },
/* Tibbits below is buttons and LEDs */
	{ TB_38,	1, TBSLOT_C1_OR_C2 },
	{ TB_39_1,	1, TBSLOT_C1_OR_C2 },
	{ TB_39_2,	1, TBSLOT_C1_OR_C2 },
	{ TB_39_3, 	1, TBSLOT_C1_OR_C2 },
	{ TB_39_4,	1, TBSLOT_C1_OR_C2 },
/* Normal tibbits again */	
	{ TB_40_1,	1, TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_40_2,	1, TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_40_3,	1, TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_40_4,	1, TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
/* Tibbit #41 is an exception - it must be paired with #00-3 to work! */
	{ TB_41,	1, TBSLOT_PIN_C_UNUSED | TBSLOT_PIN_D_UNUSED },
	{ TB_42,	1, 0 },
/* Reserved/Not exists */	
	{ TB_43,	0, 0 },
	{ TB_44,	0, 0 },
	{ TB_45,	0, 0 },
	{ TB_46,	0, 0 },
/* GPRS/GSM modem */	
	{ TB_47, 2, 0 }						//!< GPRS modem
};

/*! \brief Retrieve information about specified Tibbit type
 */
tibbit_info *tibbit_getinfo(tibbit tb)
{
	tibbit_info *t = &_ti_info[tb];
	return t->type == tb? t: 0;
}